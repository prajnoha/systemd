/* SPDX-License-Identifier: LGPL-2.1+ */

#include <errno.h>
#include <stdbool.h>

#include "alloc-util.h"
#include "device-private.h"
#include "fileio.h"
#include "id128-util.h"
#include "sd-event.h"
#include "set.h"
#include "string-util.h"
#include "time-util.h"

#include "libudev-device-internal.h"
#include "libudev-list-internal.h"

/**
 * SECTION:libudev-trigger
 * @short_description: trigger synthetic udev events
 *
 * This is an interface for triggering synthetic udev events for
 * a set of given devices. The set is defined by adding individual
 * devices to the trigger or by providing a udev device enumeration
 * object.
 *
 * Synthetic udev events are generated by kernel, but unlike genuine
 * events, these are provoked by a userspace process. This technique
 * is used to notify all event listeners back in userspace on demand,
 * including udev daemon which then reexecutes all applicable udev
 * rules and it refreshes udev database accordigly.
 *
 * All synthetic udev events always contain compulsory SYNTH_UUID=<uuid>
 * pair in the event environment where the <uuid> is in the
 * xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx format. Libudev assigns a new
 * random <uuid> for each trigger execution.
 *
 * It is also possible to pass additional key-value pairs with the
 * trigger which are then inserted into the environment of the generated
 * synthetic udev events. All these additional key-value pairs are always
 * prefixed with a 'SYNTH_ARG_' prefix to avoid conflict with any other
 * keys. The key and value in 'SYNTH_ARG_<key>=<value>' pair is restricted
 * to alphanumeric characters only, that is [a-z], [A-Z], [0-9].
 *
 */

/**
 * udev_trigger:
 *
 * Opaque context object representing the trigger.
 */
struct udev_trigger {
        struct udev *udev;
        unsigned n_ref;
        const char *action;
        char uuid[SD_ID128_UUID_STRING_MAX];
        struct udev_list *syspath_list;
        struct udev_list *properties_list;
        Set *settle_set;
};

static struct udev_trigger *udev_trigger_free(struct udev_trigger *udev_trigger) {
        udev_list_free(udev_trigger->properties_list);
        udev_list_free(udev_trigger->syspath_list);

        return mfree(udev_trigger);
}

/**
 * udev_trigger_ref:
 * @udev_trigger: udev trigger context
 *
 * Take a reference of a udev trigger context.
 *
 * Returns: passed udev trigger context
 **/

/**
 * udev_trigger_unref:
 * @udev_trigger: udev trigger context
 *
 * Drop a reference of a udev trigger context. If the refcount reaches zero,
 * all resources of the udev trigger context will be released.
 *
 * Returns: #NULL
 **/
DEFINE_PUBLIC_TRIVIAL_REF_UNREF_FUNC(struct udev_trigger, udev_trigger, udev_trigger_free);

struct udev *udev_trigger_get_udev(struct udev_trigger *udev_trigger) {
        assert_return_errno(udev_trigger, NULL, EINVAL);

        return udev_trigger->udev;
}

static int udev_trigger_ensure_uuid_set(struct udev_trigger *udev_trigger) {
        sd_id128_t id;
        int r;

        if (!isempty(udev_trigger->uuid))
                return 0;

        r = sd_id128_randomize(&id);
        if (r < 0)
                return r;

        id128_to_uuid_string(id, udev_trigger->uuid);
        return 0;
}

static inline void udev_trigger_discard_uuid(struct udev_trigger *udev_trigger) {
        udev_trigger->uuid[0] = '\0';
}

/**
 * udev_trigger_new
 * @udev: udev library context
 *
 * Create a trigger context to synthesize udev events.
 *
 * Returns: udev trigger context.
 */
_public_ struct udev_trigger *udev_trigger_new(struct udev *udev) {
        _cleanup_(udev_list_freep) struct udev_list *syspath_list = NULL;
        _cleanup_(udev_list_freep) struct udev_list *properties_list = NULL;
        struct udev_trigger *udev_trigger;
        sd_id128_t id;
        int r;

        assert_return_errno(udev, NULL, EINVAL);

        syspath_list = udev_list_new(true);
        if (!syspath_list)
                return_with_errno(NULL, ENOMEM);

        properties_list = udev_list_new(true);
        if (!properties_list)
                return_with_errno(NULL, ENOMEM);

        udev_trigger = new(struct udev_trigger, 1);
        if (!udev_trigger)
                return_with_errno(NULL, ENOMEM);

        *udev_trigger = (struct udev_trigger) {
                .udev = udev,
                .n_ref = 1,
                .action = device_action_to_string(DEVICE_ACTION_CHANGE),
                .syspath_list = TAKE_PTR(syspath_list),
                .properties_list = TAKE_PTR(properties_list),
                .settle_set = NULL,
        };

        udev_trigger_discard_uuid(udev_trigger);

        return udev_trigger;
}

/**
 * udev_trigger_set_action
 * @udev_trigger: udev trigger context
 * @action: action for the trigger, one of: add, change, remove, move, offline, online, bind, unbind.
 *
 * Set action to trigger udev events. Note that if the action is not set
 * explicitly by calling this function,  then by default 'change' action
 * is used for the trigger.
 *
 * Returns: 0 on success, otherwise a negative error value.
 */
_public_ int udev_trigger_set_action(struct udev_trigger *udev_trigger, const char *action) {
        DeviceAction device_action;

        assert_return(udev_trigger, -EINVAL);

        device_action = device_action_from_string(action);
        if (device_action < 0)
                return -EINVAL;

        udev_trigger->action = action;
        return 0;
}

/**
 * udev_trigger_get_action
 * @udev_trigger: udev trigger context
 *
 * Get action currently assigned to the trigger.
 *
 * Returns: action string
 */
_public_ const char *udev_trigger_get_action(struct udev_trigger *udev_trigger) {
        assert_return_errno(udev_trigger, NULL, EINVAL);

        return udev_trigger->action;
}

/**
 * udev_trigger_add_device
 * @udev_trigger: udev trigger context
 * @udev_device: device to add for the trigger
 *
 * Add device to the trigger so when the trigger is executed, a udev event
 * is synthesized for this device.
 *
 * Returns: 0 on success, otherwise a negative error value.
 */
_public_ int udev_trigger_add_device(struct udev_trigger *udev_trigger, struct udev_device *udev_device) {
        const char *syspath;
        int r;

        assert_return(udev_trigger, -EINVAL);

        r = sd_device_get_syspath(udev_device_get_sd_device(udev_device), &syspath);
        if (r < 0)
                return r;

        if (!udev_list_entry_add(udev_trigger->syspath_list, syspath, NULL))
                return -ENOMEM;

        return 0;
}

/**
 * udev_trigger_add_device
 * @udev_trigger: udev trigger context
 * @udev_enumerate: device enumeration context
 *
 * Add all enumerated devices to the trigger so when the trigger is executed,
 * a udev event is synthesized for each device.
 *
 * Returns: 0 on success, otherwise a negative error value.
 */
_public_ int udev_trigger_add_enumerate(struct udev_trigger *udev_trigger, struct udev_enumerate *udev_enumerate) {
        struct udev_list_entry *syspath_entry;

        assert_return(udev_trigger, -EINVAL);
        assert_return(udev_enumerate, -EINVAL);

        udev_list_entry_foreach(syspath_entry, udev_enumerate_get_list_entry(udev_enumerate)) {
                const char *syspath;

                syspath = udev_list_entry_get_name(syspath_entry);
                if (!udev_list_entry_add(udev_trigger->syspath_list, syspath, NULL))
                        return -ENOMEM;
        }

        return 0;
}

/**
 * udev_trigger_get_devices_list_entry
 * @udev_trigger: udev trigger context
 *
 * Get the first entry of the sorted list of device paths included in the trigger.
 *
 * Returns: udev list entry.
 */
_public_ struct udev_list_entry *udev_trigger_get_devices_list_entry(struct udev_trigger *udev_trigger) {
        struct udev_list_entry *entry;

        assert_return_errno(udev_trigger, NULL, EINVAL);

        entry = udev_list_get_entry(udev_trigger->syspath_list);
        if (!entry)
                return_with_errno(NULL, ENODATA);

        return entry;
}

/**
 * udev_trigger_get_uuid
 * @udev_trigger: udev trigger context
 *
 * Get the UUID which is used to mark all synthesized udev events
 * for devices when the trigger is executed. Each trigger execution
 * uses new automatically generated UUID. All the synthesized udev
 * events then contain SYNTH_UUID=UUID pair in their event environment.
 *
 * Returns: UUID used when the trigger is executed.
 */
_public_ const char *udev_trigger_get_uuid(struct udev_trigger *udev_trigger) {
        int r;

        assert_return_errno(udev_trigger, NULL, EINVAL);

        r = udev_trigger_ensure_uuid_set(udev_trigger);
        if (r < 0)
                return_with_errno(NULL, r);

        return udev_trigger->uuid;
}

/**
 * udev_trigger_add_property
 * @udev_trigger: udev trigger context
 * @key: property key (alphanumeric characters [a-z,A-Z,0-9] allowed only)
 * @value: property value (alphanumeric characters [a-z,A-Z,0-9] allowed only)
 *
 * Add key-value pair to include for all synthesized udev events for
 * devices when the trigger is executed. All the synthesized udev
 * events then contain SYNTH_ARG_KEY=VALUE pair in their event environment.
 *
 * Returns: 0 on success, otherwise a negative error value.
 */
_public_ int udev_trigger_add_property(struct udev_trigger *udev_trigger, const char *key, const char *value) {
        assert_return(udev_trigger, -EINVAL);
        assert_return(key, -EINVAL);
        assert_return(value, -EINVAL);

        if (!in_charset(key, ALPHANUMERICAL) ||
            !in_charset(value, ALPHANUMERICAL))
                return -EINVAL;

        if (!udev_list_entry_add(udev_trigger->properties_list, key, value))
                return -ENOMEM;

        return 0;
}

/**
 * udev_trigger_get_properties_list_entry
 * @udev_trigger: udev trigger context
 *
 * Get the first entry of the sorted list of properties included in the trigger.
 *
 * Returns: udev list entry.
 */
_public_ struct udev_list_entry *udev_trigger_get_properties_list_entry(struct udev_trigger *udev_trigger) {
        struct udev_list_entry *entry;

        assert_return_errno(udev_trigger, NULL, EINVAL);

        entry = udev_list_get_entry(udev_trigger->properties_list);
        if (!entry)
                return_with_errno(NULL, ENODATA);

        return entry;
}

static char *udev_trigger_construct_full_action(struct udev_trigger *udev_trigger) {
        char *full_action;
        struct udev_list_entry *property_entry;

        full_action = strjoin(udev_trigger->action, " ", udev_trigger->uuid, " UDEVTRIGGER=1");
        if (!full_action)
                return_with_errno(NULL, ENOMEM);

        udev_list_entry_foreach(property_entry, udev_list_get_entry(udev_trigger->properties_list)) {
                const char *key, *value;
                _cleanup_free_ char *s = full_action;

                key = udev_list_entry_get_name(property_entry);
                value = udev_list_entry_get_value(property_entry);

                full_action = strjoin(full_action, " ", key, "=", value);
                if (!full_action)
                        return_with_errno(NULL, ENOMEM);
        }

        return full_action;
}

static int udev_trigger_execute_common(struct udev_trigger *udev_trigger) {
        _cleanup_free_ char *full_action = NULL;
        struct udev_list_entry *syspath_entry;
        int r;

        assert_return(udev_trigger, -EINVAL);

        full_action = udev_trigger_construct_full_action(udev_trigger);
        if (!full_action)
                return_with_errno(-1, ENOMEM);

        udev_list_entry_foreach(syspath_entry, udev_list_get_entry(udev_trigger->syspath_list)) {
                _cleanup_free_ char *sys_uevent_path = NULL;
                _cleanup_free_ char *key = NULL;
                const char *syspath;

                syspath = udev_list_entry_get_name(syspath_entry);

                sys_uevent_path = strjoin(syspath, "/uevent");
                if (!sys_uevent_path)
                        continue;

                r = write_string_file(sys_uevent_path, full_action, WRITE_STRING_FILE_DISABLE_BUFFER);
                if (r < 0)
                        continue;

                if (!set_isempty(udev_trigger->settle_set)) {
                        key = strjoin(udev_trigger->uuid, syspath);
                        if (!key)
                                continue;

                        r = set_put_strdup(udev_trigger->settle_set, key);
                        if (r < 0)
                                continue;
                }
        }

        return 0;
}

/**
 * udev_trigger_execute
 * @udev_trigger: udev trigger context
 *
 * Execute the trigger, causing the synthesized udev events to be generated for all
 * devices included in the trigger.
 *
 * Returns: 0 on success, otherwise a negative error value.
 */
_public_ int udev_trigger_execute(struct udev_trigger *udev_trigger) {
        int r;

        udev_trigger->settle_set = NULL;

        r = udev_trigger_ensure_uuid_set(udev_trigger);
        if (r < 0)
                return r;

        r = udev_trigger_execute_common(udev_trigger);

        udev_trigger_discard_uuid(udev_trigger);

        return r;
}

static int udev_trigger_monitor_handler(sd_device_monitor *monitor, sd_device *device, void *userdata)
{
        struct udev_trigger *udev_trigger = userdata;
        _cleanup_free_ char *key = NULL;
        _cleanup_free_ char *val = NULL;
        const char *syspath, *uuid;

        assert(device);
        assert(udev_trigger->settle_set);

        if (sd_device_get_syspath(device, &syspath) < 0)
                return 0;

        if (sd_device_get_property_value(device, "SYNTH_UUID", &uuid) < 0)
                return 0;

        if (!streq(uuid, udev_trigger->uuid))
                return 0;

        key = strjoin(uuid, syspath);
        if (!key)
                return -ENOMEM;

        (void) set_remove(udev_trigger->settle_set, key);

        if (set_isempty(udev_trigger->settle_set))
                return sd_event_exit(sd_device_monitor_get_event(monitor), 0);

        return 0;
}

static int udev_trigger_timeout_handler(sd_event_source *s, uint64_t usec, void *userdata)
{
        (void) sd_event_exit(sd_event_source_get_event(s), -ETIMEDOUT);
        return 1;
}

/**
 * udev_trigger_execute_with_settle
 * @udev_trigger: udev trigger context
 * @timeout_sec: timeout in seconds for related udev event processing to settle down.
 *
 * Execute the trigger, causing the synthesized udev events to be generated
 * for all devices included in the trigger and wait for all the related udev
 * event processing in udevd to settle down. Return if the settle does not
 * happen within specified timeout.
 *
 * Returns: 0 on success, -ETIMEDOUT on timeout, negative error value for any other error.
 */
_public_ int udev_trigger_execute_with_settle(struct udev_trigger *udev_trigger, unsigned int timeout_sec) {
        _cleanup_set_free_free_ Set *settle_set = NULL;
        _cleanup_(sd_event_unrefp) sd_event *event = NULL;
        _cleanup_(sd_device_monitor_unrefp) sd_device_monitor *monitor = NULL;
        _cleanup_(sd_event_source_unrefp) sd_event_source *timeout = NULL;
        uint64_t now_usec;
        int r;

        udev_trigger->settle_set = settle_set = set_new(&string_hash_ops);
        if (!settle_set)
                return -ENOMEM;

        r = sd_event_default(&event);
        if (r < 0)
                return r;

        r = sd_device_monitor_new(&monitor);
        if (r < 0)
                return r;

        r = sd_device_monitor_attach_event(monitor, event);
        if (r < 0)
                return r;

        if (timeout_sec > 0) {
                assert_se(sd_event_now(event, CLOCK_MONOTONIC, &now_usec) >= 0);

                r = sd_event_add_time(event, &timeout, CLOCK_MONOTONIC,
                                      now_usec + timeout_sec * USEC_PER_SEC, USEC_PER_SEC,
                                      udev_trigger_timeout_handler, udev_trigger);
                if (r < 0)
                        return r;
        }

        r = sd_device_monitor_start(monitor, udev_trigger_monitor_handler, udev_trigger);
        if (r < 0)
                return r;

        r = udev_trigger_ensure_uuid_set(udev_trigger);
        if (r < 0)
                return r;

        r = udev_trigger_execute_common(udev_trigger);
        if (r < 0) {
                udev_trigger_discard_uuid(udev_trigger);
                return r;
        }

        r = sd_event_loop(event);

        udev_trigger_discard_uuid(udev_trigger);

        if (r < 0)
                return r;

        return 0;
}
